package MetaModel.structure;

/*Generated by MPS */

import jetbrains.mps.smodel.runtime.ConceptPresentationAspectBase;
import jetbrains.mps.smodel.runtime.ConceptPresentation;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.mps.openapi.language.SAbstractConcept;
import jetbrains.mps.smodel.runtime.ConceptPresentationBuilder;

public class ConceptPresentationAspectImpl extends ConceptPresentationAspectBase {
  private ConceptPresentation props_Association;
  private ConceptPresentation props_AttributeConnector;
  private ConceptPresentation props_Bidirectional;
  private ConceptPresentation props_Class;
  private ConceptPresentation props_Connector;
  private ConceptPresentation props_ConstrainedTargetConnector;
  private ConceptPresentation props_Exception;
  private ConceptPresentation props_Generalisation;
  private ConceptPresentation props_Management;
  private ConceptPresentation props_MapConnector;
  private ConceptPresentation props_Operation;
  private ConceptPresentation props_OwnerConnector;
  private ConceptPresentation props_Parameter;
  private ConceptPresentation props_PrimitiveType;
  private ConceptPresentation props_RelationType;
  private ConceptPresentation props_Service;
  private ConceptPresentation props_TargetConnector;
  private ConceptPresentation props_Type;
  private ConceptPresentation props_TypeAdapter;
  private ConceptPresentation props_Unidirectional;

  @Override
  @Nullable
  public ConceptPresentation getDescriptor(SAbstractConcept c) {
    StructureAspectDescriptor structureDescriptor = (StructureAspectDescriptor) myLanguageRuntime.getAspect(jetbrains.mps.smodel.runtime.StructureAspectDescriptor.class);
    switch (structureDescriptor.internalIndex(c)) {
      case LanguageConceptSwitch.Association:
        if (props_Association == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Binary Relation Type");
          cpb.presentationByName();
          props_Association = cpb.create();
        }
        return props_Association;
      case LanguageConceptSwitch.AttributeConnector:
        if (props_AttributeConnector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Connector which targets a primitive type, specializes the targetType of its superconcept ");
          cpb.rawPresentation("AttributeConnector");
          props_AttributeConnector = cpb.create();
        }
        return props_AttributeConnector;
      case LanguageConceptSwitch.Bidirectional:
        if (props_Bidirectional == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Constraint on association's domain: Injective, Surjective or both");
          cpb.rawPresentation("Bidirectional");
          props_Bidirectional = cpb.create();
        }
        return props_Bidirectional;
      case LanguageConceptSwitch.Class:
        if (props_Class == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Complex Type (Unary Relation Type)");
          cpb.presentationByName();
          props_Class = cpb.create();
        }
        return props_Class;
      case LanguageConceptSwitch.Connector:
        if (props_Connector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Carries information that describes an association's end");
          props_Connector = cpb.create();
        }
        return props_Connector;
      case LanguageConceptSwitch.ConstrainedTargetConnector:
        if (props_ConstrainedTargetConnector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("A target connector with multiplicity at the codomain side of an association");
          cpb.rawPresentation("ConstrainedTargetConnector");
          props_ConstrainedTargetConnector = cpb.create();
        }
        return props_ConstrainedTargetConnector;
      case LanguageConceptSwitch.Exception:
        if (props_Exception == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("An exception class");
          cpb.presentationByName();
          props_Exception = cpb.create();
        }
        return props_Exception;
      case LanguageConceptSwitch.Generalisation:
        if (props_Generalisation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("An instance of a partial ordering on classes");
          cpb.rawPresentation("Generalisation");
          props_Generalisation = cpb.create();
        }
        return props_Generalisation;
      case LanguageConceptSwitch.Management:
        if (props_Management == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Refers to the management of a relation R subseteq A x B, which specifies references FROM A TO B. It can be unmanaged, i.e. the cardinality at A is *. Otherwise there must be management, e.g. if for each :B there is at most one :A (injectivity).");
          props_Management = cpb.create();
        }
        return props_Management;
      case LanguageConceptSwitch.MapConnector:
        if (props_MapConnector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("A special target connector for a ternary association owner -> key -> value where value has targetType from TargetConnector is again a relation and key -> value is a map");
          cpb.rawPresentation("MapConnector");
          props_MapConnector = cpb.create();
        }
        return props_MapConnector;
      case LanguageConceptSwitch.Operation:
        if (props_Operation == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Class bound Operation");
          cpb.rawPresentation("Operation");
          props_Operation = cpb.create();
        }
        return props_Operation;
      case LanguageConceptSwitch.OwnerConnector:
        if (props_OwnerConnector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Contains the type of an associations domain");
          cpb.rawPresentation("OwnerConnector");
          props_OwnerConnector = cpb.create();
        }
        return props_OwnerConnector;
      case LanguageConceptSwitch.Parameter:
        if (props_Parameter == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Formal Parameter in an Operation");
          cpb.presentationByName();
          props_Parameter = cpb.create();
        }
        return props_Parameter;
      case LanguageConceptSwitch.PrimitiveType:
        if (props_PrimitiveType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Primitive Data Type - Cannot be Created");
          cpb.presentationByName();
          props_PrimitiveType = cpb.create();
        }
        return props_PrimitiveType;
      case LanguageConceptSwitch.RelationType:
        if (props_RelationType == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Specifies relations of arbitrary arity. As a type it has arity 1, otherwise > 1");
          props_RelationType = cpb.create();
        }
        return props_RelationType;
      case LanguageConceptSwitch.Service:
        if (props_Service == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Root node for a service specification. No two relations have the same name. If an association a1 uses another association a2 via targetConnctors, a2 must be defined before a1.");
          cpb.presentationByName();
          props_Service = cpb.create();
        }
        return props_Service;
      case LanguageConceptSwitch.TargetConnector:
        if (props_TargetConnector == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("Contains the type of an associations's codomain");
          props_TargetConnector = cpb.create();
        }
        return props_TargetConnector;
      case LanguageConceptSwitch.Type:
        if (props_Type == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("An arbitrary type is either primitive or complex (a class). In both cases we can see it as a unary relation.");
          props_Type = cpb.create();
        }
        return props_Type;
      case LanguageConceptSwitch.TypeAdapter:
        if (props_TypeAdapter == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("A type together with the Information whether it occurs as Collection");
          cpb.presentationByReference(0x9859e7a148764909L, 0xa6648a214c206698L, 0x1b4ca0733ccbe49aL, 0x1b4ca0733ccbe49dL, "type", "", "");
          props_TypeAdapter = cpb.create();
        }
        return props_TypeAdapter;
      case LanguageConceptSwitch.Unidirectional:
        if (props_Unidirectional == null) {
          ConceptPresentationBuilder cpb = new ConceptPresentationBuilder();
          cpb.shortDesc("The unmanaged domain of a relation ");
          cpb.rawPresentation("Unidirectional");
          props_Unidirectional = cpb.create();
        }
        return props_Unidirectional;
    }
    return null;
  }
}
