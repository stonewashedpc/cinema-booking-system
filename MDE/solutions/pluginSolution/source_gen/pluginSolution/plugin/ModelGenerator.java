package pluginSolution.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SModel;
import java.util.List;
import metaModel.JService;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.core.behavior.BaseConcept__BehaviorDescriptor;
import java.util.Date;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import javaASTTraversals.referenceCompletion.ReferenceCompletionVisitor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;

public class ModelGenerator {
  private static final Logger LOG = LogManager.getLogger(ModelGenerator.class);
  private SModel theModel;
  private String mpsProjectPath;
  public ModelGenerator(SModel theModel, String mpsProjectPath) {
    this.theModel = theModel;
    this.mpsProjectPath = mpsProjectPath;
  }
  public List<JService> executeModel() {
    List<ServiceGenerator> serviceGenerators = new ArrayList<ServiceGenerator>();
    for (SNode currentNode : ListSequence.fromList(SModelOperations.nodes(this.theModel, CONCEPTS.Service$gZ))) {
      //  We exclude the baseType Service, because it is not necessary to generate it 
      if (BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(currentNode).equals("baseTypes")) {
        continue;
      }
      ServiceGenerator serviceGenerator = new ServiceGenerator(currentNode, this.mpsProjectPath);
      serviceGenerators.add(serviceGenerator);
      //  First pass: Create one service excluding references to external classes 
      try {
        serviceGenerator.processNode(new ArrayList<JService>());
      } catch (Exception e) {
        String message = e.getClass().getName() + "::: " + e.getMessage();
        if (e.getCause() != null) {
          message = message + ". Cause : " + e.getCause();
        }
        serviceGenerator.informationMessage("Java AST Creation was Aborted @  " + new Date().toString() + ". " + message);
        serviceGenerator.writeProtocol(BaseConcept__BehaviorDescriptor.getPresentation_idhEwIMiw.invoke(currentNode));
        LoggingRuntime.logMsgView(Level.INFO, message + ". Aborted Model Compilation! ", ModelGenerator.class, null, null);
        return null;
      }
    }
    //  Second pass: Update external references 
    List<JService> result = new ArrayList<JService>();
    for (ServiceGenerator currentServiceGenerator : serviceGenerators) {
      JService currentService = currentServiceGenerator.getMyService();
      currentServiceGenerator.informationMessage(currentService.getName() + ": Trying to Assign Unassigned References by Searching in other Services.");
      ReferenceCompletionVisitor rcv = new ReferenceCompletionVisitor(currentService, this.calculateLMinusS(serviceGenerators, currentService));
      currentService.accept(rcv);
      currentServiceGenerator.generateJavaCode();
      try {
        currentServiceGenerator.writeXML();
      } catch (Exception e) {
        currentServiceGenerator.informationMessage("Could not write XML File: " + e.getMessage());
      }
      currentServiceGenerator.writeProtocol(currentService.getName());
      result.add(currentService);
    }
    return result;
  }
  private List<JService> calculateLMinusS(List<ServiceGenerator> l, JService s) {
    List<JService> result = new ArrayList<JService>();
    for (ServiceGenerator current : l) {
      if (current.getMyService() != s) {
        result.add(current.getMyService());
      }
    }
    return result;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Service$gZ = MetaAdapterFactory.getConcept(0x9859e7a148764909L, 0xa6648a214c206698L, 0x355f4a6bd0ef9b51L, "MetaModel.structure.Service");
  }
}
